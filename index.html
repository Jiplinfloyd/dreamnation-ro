<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title> Choisis ton Running Order - Dream Nation</title>
  <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;600;800&display=swap" rel="stylesheet">
  <style>
:root{
  --bg: #0a0a0f;
  --bg2:#0e0e16;
  --text:#e9eef2;
  --muted:#9aa3ab;
  --card:#12121c;
  --stroke:#222334;
  --accent1:#ff00e6;   /* magenta */
  --accent2:#00e5ff;   /* cyan */
  --gold:#FFD700;      /* pour ton PDF / tableaux */
}

*{box-sizing:border-box}
html,body{margin:0}
body{
  background:
    radial-gradient(1200px 600px at 10% -10%, #11131f 0%, transparent 60%),
    radial-gradient(1000px 500px at 110% 10%, #0f1130 0%, transparent 60%),
    linear-gradient(180deg, var(--bg) 0%, var(--bg2) 100%);
  color:var(--text);
  font-family: "Montserrat", system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
  text-align:center;
  padding:28px 20px 40px;
}

/* Titres */
h1{
  margin:0 0 12px;
  font-weight:800; letter-spacing:.5px;
  text-transform:uppercase;
  background: linear-gradient(90deg, var(--accent1), var(--accent2));
  -webkit-background-clip:text; background-clip:text; color:transparent;
  text-shadow: 0 0 16px rgba(255,0,230,.15), 0 0 18px rgba(0,229,255,.12);
}

.day-group{margin:36px auto 28px; max-width:1100px; text-align:left;}
.day-group h3{
  margin:0 0 14px; padding:0 2px;
  font-size:20px; font-weight:800; letter-spacing:.5px; text-transform:uppercase;
  color:#fff;
  position:relative;
}
.day-group h3::after{
  content:"";
  display:block; height:3px; margin-top:8px; border-radius:3px;
  background:linear-gradient(90deg,var(--accent1),var(--accent2));
  box-shadow: 0 0 18px rgba(255,0,230,.35), 0 0 22px rgba(0,229,255,.3);
}

/* Boutons */
button{
  font-size:15px; font-weight:700; letter-spacing:.3px; text-transform:uppercase;
  padding:12px 18px; border:none; border-radius:12px; cursor:pointer;
  color:#081018;
  background:linear-gradient(90deg, var(--accent1), var(--accent2));
  box-shadow: 0 8px 24px rgba(0,229,255,.18), inset 0 0 0 1px rgba(255,255,255,.06);
  transition: transform .08s ease, box-shadow .2s ease, filter .2s ease;
}
button:hover{ transform: translateY(-1px); filter:brightness(1.05); }
button:active{ transform: translateY(0); }

/* Grille des créneaux */
.slot{
  display:flex; flex-direction:column; gap:12px;
  max-width:1000px; margin:16px auto; text-align:left;
  padding-left:12px; border-left:3px solid transparent;
  border-image: linear-gradient(180deg, var(--accent1), var(--accent2)) 1;
}
.slot .heure{
  font-weight:800; letter-spacing:.5px;
  color:#fff; opacity:.95;
}

/* Conteneur des options : en flex, retour à la ligne */
.slot .options{
  display:flex;
  flex-wrap:wrap;
  gap:12px;
}

/* Les cartes artistes s'adaptent, mais jamais trop petites */
.option{
  flex:1 1 280px; /* ← largeur mini 280px, s'étire sinon */
}


/* Cartes cliquables (glass) */
.option{
  position:relative;
  border:1px solid var(--stroke);
  background: linear-gradient(180deg, rgba(255,255,255,.02), rgba(255,255,255,.01));
  border-radius:16px; padding:12px 14px; cursor:pointer;
  transition: border-color .15s, box-shadow .15s, background .15s, transform .05s;
}
.option:hover{ border-color:#2d2f45; background:rgba(255,255,255,.03); }
.option strong{ display:block; font-weight:800; color:#fff; }
.option small { display:block; margin-top:4px; color:var(--muted); }

/* cacher le radio */
.option input[type="radio"]{
  position:absolute; opacity:0; width:0; height:0; pointer-events:none;
}

/* état sélectionné via :has (modern) + fallback .selected */
.option:has(input[type="radio"]:checked),
.option.selected{
  border-color:transparent;
  background: rgba(10,20,30,.25);
  box-shadow:
    0 0 0 1px rgba(255,255,255,.06) inset,
    0 0 24px rgba(255,0,230,.20),
    0 0 28px rgba(0,229,255,.18);
}
.option:has(input[type="radio"]:checked) strong,
.option:has(input[type="radio"]:checked) small,
.option.selected strong,
.option.selected small{
  color:#e8fbff;
  text-shadow: 0 0 10px rgba(0,229,255,.25);
}

/* Résultats */
#resultats h2{
  text-transform:uppercase; letter-spacing:.5px;
}

table {
  background: #0d1117;
  border-radius: 14px;
  overflow: hidden;
  color: #fff;
  border-collapse: collapse;
  font-family: Montserrat, sans-serif;
  font-size: 12px;
}
th {
  background: linear-gradient(90deg, #ff00e6, #00e5ff);
  color: #fff;
  text-transform: uppercase;
  font-size: 13px;
  padding: 8px;
}
td {
  border: 1px solid #333;
  padding: 8px;
}


/* Mobile */
@media (max-width:740px){
  body{ padding:18px 14px 28px; }
}

.hidden {
  display: none;
}

#liste-resultats table td,
#liste-resultats table th {
  box-shadow: 0 0 6px rgba(128,0,255,0.6);
}

.jour-titre {
  margin: 50px 0 20px;
  font-size: 1.8em;
  text-align: center;
  color: #4b0082; /* violet festival */
  font-weight: 700;
  position: relative;
}
.jour-titre::after {
  content: "";
  display: block;
  width: 80px;
  height: 3px;
  margin: 6px auto 0;
  background: linear-gradient(90deg, #ff00e6, #00e5ff);
  border-radius: 2px;
}


.option-none {
  width: 120px;      /* largeur fixe */
  height: 70px;      /* hauteur fixe */
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
  text-align: center;
}

.option-none strong {
  font-size: 14px;
}

.option-none small {
  display: none; /* inutile pour "Aucun" */
}

.option.selected {
  border-color: transparent;
  background: rgba(10,20,30,.45);
  box-shadow: 0 0 18px rgba(255,0,230,.35), 0 0 22px rgba(0,229,255,.35);
}

.option.selected strong {
  color: #ff00e6; /* texte principal néon rose */
}

.option.selected small {
  color: #00e5ff; /* sous-texte en cyan */
}

/* Couleurs du texte quand sélectionné */
.option.selected strong { color:#ff00e6 !important; }  /* rose néon */
.option.selected small  { color:#00e5ff !important; }  /* cyan */

/* Si le navigateur supporte :has, colorer aussi via :has() */
.option:has(input[type="radio"]:checked) strong { color:#ff00e6 !important; }
.option:has(input[type="radio"]:checked) small  { color:#00e5ff !important; }

/* Pulse néon doux sur l'option sélectionnée */
@keyframes neonPulse{
  0%,100%{
    box-shadow:
      0 0 0 1px rgba(255,255,255,.06) inset,
      0 0 18px rgba(255,0,230,.28),
      0 0 22px rgba(0,229,255,.26);
  }
  50%{
    box-shadow:
      0 0 0 1px rgba(255,255,255,.08) inset,
      0 0 28px rgba(255,0,230,.45),
      0 0 34px rgba(0,229,255,.42);
  }
}

/* Appliquer le pulse uniquement à l'état sélectionné */
.option.selected,
.option:has(input[type="radio"]:checked){
  animation: neonPulse 1.6s ease-in-out infinite;
}

/* Respecte la préférence "réduire les animations" */
@media (prefers-reduced-motion: reduce){
  .option.selected,
  .option:has(input[type="radio"]:checked){
    animation: none;
  }
}

/* Affichage de l'intervalle */
.option .time { opacity:.9; }

/* Afficher clairement les conflits horaires */
.option.conflict::after{
  content:"Conflit horaire";
  position:absolute; top:8px; right:12px;
  font-size:11px; padding:2px 6px; border-radius:999px;
  background: rgba(255,0,230,.18);
  color:#ff8ae8;
  border:1px solid rgba(255,0,230,.35);
}
.option.conflict input{ pointer-events:auto; }

/* Partiel : autorisé, affiche "Restant XX min avant/après" */
.option.partial{
  opacity:.9;
  position: relative;
  outline: 1px dashed rgba(255,165,0,.35);
}
.option.partial::after{
  content: "Restant " attr(data-remmin) " min " attr(data-dir);
  position:absolute; top:8px; right:12px;
  font-size:11px; padding:2px 6px; border-radius:999px;
  background: rgba(255,165,0,.18);
  color:#ffb84d;
  border:1px solid rgba(255,165,0,.35);
}

/* Conflit dur : moins de WATCHABLE_MIN */
.option.conflict{
  opacity:.6;
  filter: grayscale(.15);
  position: relative;
}
.option.conflict::after{
  content:"Restant " attr(data-remmin) " min " attr(data-dir) " (conflit)";
  position:absolute; top:8px; right:12px;
  font-size:11px; padding:2px 6px; border-radius:999px;
  background: rgba(255,0,230,.18);
  color:#ff8ae8;
  border:1px solid rgba(255,0,230,.35);
}
/* Petite ligne d’info sur le chevauchement */
.option .ov-note{
  margin-top: 6px;
  font-size: 11px;
  line-height: 1.25;
  color: #cfcfe6;
  opacity: .9;
}
.option.partial .ov-note{ color:#ffb84d; }     /* partiel = orange */
.option.conflict .ov-note{ color:#ff8ae8; }    /* conflit dur = rose */

/* Badge de note dans le tableau */
.note-badge{
  display:inline-block;
  font-size:11px;
  padding:2px 8px;
  border-radius:999px;
  border:1px solid;
  white-space:nowrap;
}
.note-badge.partial{
  color:#ffb84d; background:rgba(255,165,0,.12); border-color:rgba(255,165,0,.35);
}
.note-badge.conflict{
  color:#ff8ae8; background:rgba(255,0,230,.12); border-color:rgba(255,0,230,.35);
}

/* Mini timeline */
.tl-cell{
  width:100%; height:22px; position:relative;   /* ← plus de largeur fixe */
  background:#f5f7fa; border:1px solid #e2e8f0; border-radius:6px;
  overflow:hidden;
}
.tl-range{
  position:absolute; top:0; bottom:0; border-radius:6px;
  background: linear-gradient(90deg, #ff00e6, #00e5ff);
  opacity:.85;
}
.tl-label{
  position:absolute; inset:0; display:flex; align-items:center; justify-content:center;
  font-size:11px; color:#0b1320; font-weight:700; mix-blend:normal;
}

/* === MODE PDF : couleurs claires + largeur sûre === */
body.pdf-mode { background:#fff; color:#111; }
body.pdf-mode #resultats { color:#111; }

/* tableau lisible à l'impression */
body.pdf-mode table { background:#fff; border-color:#7b61ff; }
body.pdf-mode th { background:#eef0ff; color:#111; }
body.pdf-mode td { background:#fff; }

/* badges de note : fond clair + texte foncé */
body.pdf-mode .note-badge.partial{
  color:#8a5a00; background:#fff; border-color:#f0c27a;
}
body.pdf-mode .note-badge.conflict{
  color:#7a2a6e; background:#fff; border-color:#d29ad0;
}

/* timeline : fond blanc, bord violet doux, barre gris neutre */
body.pdf-mode .tl-cell{ background:#fff; border-color:#7b61ff; }
body.pdf-mode .tl-range{
  background:#999; opacity:.35;  /* pas de dégradé flashy sur le PDF */
}
body.pdf-mode #liste-resultats { max-width: 100% !important; }
body.pdf-mode table { width: 100% !important; table-layout: fixed; }

/* ——— TABLEAU : largeur fixe & compacité en PDF ——— */
body.pdf-mode table { table-layout: fixed; width: 100% !important; }
body.pdf-mode th, body.pdf-mode td { padding: 6px 8px !important; font-size: 12px !important; }

/* Heures : pas de retour à la ligne */
.nowrap { white-space: nowrap; }

/* Timeline : taille raisonnable en PDF */
body.pdf-mode .tl-cell { height: 18px; }
body.pdf-mode .tl-label { font-size: 10px; }

/* Empêche la timeline de déborder en PDF */
body.pdf-mode .tl-cell{
  width: 100% !important;     /* prend tout l'espace de la colonne */
  max-width: 100% !important;
}

/* sécurité : pas de dépassement horizontal */
body.pdf-mode .tl-range{ right: 0; }      /* au cas où */
body.pdf-mode .tl-cell, 
body.pdf-mode .tl-label{ overflow: hidden; }


/* ===== PDF MODE – largeur sûre et texte qui s'enroule ===== */
body.pdf-mode * { box-sizing: border-box !important; }

body.pdf-mode #liste-resultats,
body.pdf-mode .jour-section { width: 100% !important; max-width: 100% !important; }

body.pdf-mode table {
  table-layout: fixed;
  width: 100% !important;
  border-collapse: collapse;
}

body.pdf-mode th, body.pdf-mode td {
  padding: 6px 8px !important;
  font-size: 12px !important;
}

/* Colonne NOTE : autoriser l’enroulement + empêcher l'overflow */
td.col-note { overflow: hidden; }
.note-badge{
  display: block;            /* occupe toute la largeur de la cellule */
  white-space: normal;       /* autorise retour à la ligne */
  word-break: break-word;    /* casse proprement si besoin */
  line-height: 1.2;
  max-width: 100%;
}
body.pdf-mode .note-badge{ font-size: 11px; }



  </style>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
</head>
<body>
  <h1>Fais ton choix pour chaque créneau</h1>

<div id="selection-jours">
  <p>Quels jours fais-tu au festival ?</p>
  <label><input type="checkbox" value="Vendredi 26" checked> Vendredi 26</label><br>
  <label><input type="checkbox" value="Samedi 27" checked> Samedi 27</label><br>
  <button id="btnStart" type="button">Commencer</button>
</div>


  <div id="choix" class="hidden"></div>
  <div id="resultats" class="hidden">
  <h2>Ton Running Order</h2>
  <ul id="liste-resultats"></ul>
  <button onclick="genererPDF()">📅 Télécharger en PDF</button>
  <button type="button" id="btnResetMem">Effacer mes choix mémorisés</button>
</div>



  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
  <script>
	let donneesFestival = {
	  "Samedi 27": [
			{ heure: "00h00", artistes: [
			  { nom: "LB AKA LABAT", style: "Electro / House", scene: "Lunar Stage", fin: "1h00" },
			  { nom: "25EMEHEURE", style: "Hard Techno", scene: "Organik Stage", fin: "1h30" },
			]},
			{ heure: "00h15", artistes: [
			  { nom: "WILKINSON", style: "Drum & Bass", scene: "Bassquake Stage", fin: "1h15" },
			]},
			{ heure: "1h00", artistes: [
			  { nom: "FUNK TRIBU b2b MISCHLUFT", style: "Techno", scene: "Lunar Stage", fin: "2h15" },
			]},
			{ heure: "1h15", artistes: [
			  { nom: "ANDY C", style: "Drum & Bass", scene: "Bassquake Stage", fin: "2h15" },
			]},
			{ heure: "1h30", artistes: [
			  { nom: "NØNAME", style: "Techno / Electro", scene: "Organik Stage", fin: "3h00" },
			]},
			{ heure: "2h15", artistes: [
			  { nom: "VINI VICI", style: "Psytrance", scene: "Lunar Stage", fin: "3h15" },
			  { nom: "KAYZO b2b MUST DIE!", style: "Bass / Hard Dance / Dubstep", scene: "Bassquake Stage", fin: "3h15" },
			]},
			{ heure: "3h00", artistes: [
			  { nom: "BALAGAN", style: "Techno", scene: "Organik Stage", fin: "4h00" },
			]},
			{ heure: "3h15", artistes: [
			  { nom: "ASTRIX", style: "Psytrance", scene: "Lunar Stage", fin: "4h15" },
			  { nom: "KANINE b2b SOTA", style: "Drum & Bass", scene: "Bassquake Stage", fin: "4h15" },
			]},
			{ heure: "4h00", artistes: [
			  { nom: "OBSTN", style: "Techno", scene: "Organik Stage", fin: "5h00" },
			]},
			{ heure: "4h15", artistes: [
			  { nom: "ACE VENTURA", style: "Progressive Psytrance", scene: "Lunar Stage", fin: "5h15" },
			  { nom: "INFEKT b2b SAMPLIFIRE", style: "Riddim / Dubstep", scene: "Bassquake Stage", fin: "5h15" },
			]},
			{ heure: "5h00", artistes: [
			  { nom: "RHADAMANTHE", style: "Techno", scene: "Organik Stage", fin: "6h00" },
			]},
			{ heure: "5h15", artistes: [
			  { nom: "MANDIDEXTROUS", style: "Jungle / 160-170", scene: "Bassquake Stage", fin: "6h15" },
			  { nom: "EARGASM GOD", style: "Techno", scene: "Lunar Stage", fin: "6h15" },
			]},
			{ heure: "20h30", artistes: [
			  { nom: "HIBI", style: "Trancy/Groovy", scene: "Organik Stage", fin: "22h00" },
			]},
			{ heure: "21h00", artistes: [
			  { nom: "ASDEK", style: "Bass House", scene: "Bassquake Stage", fin: "21h45" },
			]},
			{ heure: "21h10", artistes: [
			  { nom: "HILIGHT TRIBE", style: "Trance / Tribal (Live)", scene: "Lunar Stage", fin: "22h40" },
			]},
			{ heure: "21h45", artistes: [
			  { nom: "MALAA × ALTER EGO", style: "House / Bass House", scene: "Bassquake Stage", fin: "23h15" },
			]},
			{ heure: "22h00", artistes: [
			  { nom: "PEAKSOU", style: "Trance/Hypertechno", scene: "Organik Stage", fin: "23h00" },
			]},
			{ heure: "23h00", artistes: [
			  { nom: "PERCEVAL", style: "Psytrance", scene: "Lunar Stage", fin: "23h55" },
			  { nom: "MANIL", style: "Hard Techno/Groove", scene: "Organik Stage", fin: "00h00" },
			]},
			{ heure: "23h15", artistes: [
			  { nom: "ZOMBOY", style: "Dubstep", scene: "Bassquake Stage", fin: "00h15" },
			]},
	  ],
	  "Vendredi 26": [
			{ heure: "00h15", artistes: [
			  { nom: "999999999", style: "Acid Techno", scene: "Pulsar Stage", fin: "1h15" },
			]},
			{ heure: "00h30", artistes: [
			  { nom: "SUB ZERO PROJECT", style: "Hardstyle", scene: "Warzone Stage", fin: "1h30" },
			]},
			{ heure: "1h00", artistes: [
			  { nom: "SIBI", style: "Trance/Hardstyle/Hardcore oldschool", scene: "2much stage", fin: "2h15" },
			]},
			{ heure: "1h15", artistes: [
			  { nom: "OGUZ", style: "Techno", scene: "Pulsar Stage", fin: "2h15" },
			]},
			{ heure: "1h30", artistes: [
			  { nom: "ROOLER", style: "Raw Hardstyle", scene: "Warzone Stage", fin: "2h30" },
			]},
			{ heure: "2h15", artistes: [
			  { nom: "DYEN b2b STAN CHRIST", style: "Neorave / Hard Techno", scene: "Pulsar Stage", fin: "3h30" },
			  { nom: "SHANIXX", style: "Techno bitchy 2000", scene: "2much stage", fin: "3h30" },
			]},
			{ heure: "2h30", artistes: [
			  { nom: "BILLX b2b VANDAL", style: "Hardtek / Raggatek", scene: "Warzone Stage", fin: "3h30" },
			]},
			{ heure: "3h30", artistes: [
			  { nom: "REINIER ZONNEVELD b2b ANGERFIST", style: "Techno", scene: "Pulsar Stage", fin: "4h30" },
			  { nom: "SEFA", style: "Frenchcore", scene: "Warzone Stage", fin: "4h25" },
			  { nom: "DJ SCHNAKE", style: "Chipiecore/Trance/happy Hardcore/pop", scene: "2much stage", fin: "4h45" },
			]},
			{ heure: "4h25", artistes: [
			  { nom: "MISS K8 b2b ANIME", style: "Hardcore", scene: "Warzone Stage", fin: "5h20" },
			]},
			{ heure: "4h30", artistes: [
			  { nom: "VIEZE ASBAK", style: "Hard Techno", scene: "Pulsar Stage", fin: "5h15" },
			]},
			{ heure: "4h45", artistes: [
			  { nom: "AVENIR", style: "Acid rave/Hard Techno/Electro/Punk rock", scene: "2much stage", fin: "6h00" },
			]},
			{ heure: "5h15", artistes: [
			  { nom: "HADES", style: "Melodic Industrial Techno", scene: "Pulsar Stage", fin: "6h15" },
			]},
			{ heure: "5h20", artistes: [
			  { nom: "MAJOR CONSPIRACY b2b PARTYRAISER", style: "Hardcore Uptempo", scene: "Warzone Stage", fin: "6h15" },
			]},
			{ heure: "21h00", artistes: [
			  { nom: "SKONE & PROTOSKEED present SILENCE", style: "Tekno", scene: "Warzone Stage", fin: "22h00" },
			  { nom: "NICE KEED", style: "Fast & Hard Techno", scene: "Pulsar Stage", fin: "22h15" },
			]},
			{ heure: "22h00", artistes: [
			  { nom: "SPICE UP!", style: "Tekno", scene: "Warzone Stage", fin: "23h00" },
			  { nom: "LUX", style: "Hard Trance", scene: "2much stage", fin: "23h30" },
			]},
			{ heure: "22h15", artistes: [
			  { nom: "ZORZA", style: "Hyper Techno", scene: "Pulsar Stage", fin: "23h15" },
			]},
			{ heure: "23h00", artistes: [
			  { nom: "MAD DOG", style: "Hardcore italien", scene: "Warzone Stage", fin: "23h45" },
			]},
			{ heure: "23h15", artistes: [
			  { nom: "ACENDANT VIERGE", style: "Avant-garde Electro", scene: "Pulsar Stage", fin: "00h15" },
			]},
			{ heure: "23h30", artistes: [
			  { nom: "SHOSHANA", style: "Hard Techno/Ghetto beats/Groove", scene: "2much stage", fin: "1h00" },
			]},
			{ heure: "23h45", artistes: [
			  { nom: "VON BIKRAV", style: "Gangsta rap Gabber", scene: "Warzone Stage", fin: "00h30" },
			]},
	  ],
	};
		
		let joursChoisis = [];

		// --- Mémoire des choix (clé spécifique à la page/festival) ---
		const STORAGE_KEY = `RO:${location.pathname}:${document.title}`;

		// Sauvegarde les radios sélectionnées (un par créneau)
		function saveSelections(){
		  const data = {};
		  document.querySelectorAll('#choix input[type=radio]:checked').forEach(r => {
			data[r.name] = r.value; // ex: { "Vendredi 18_21:40": "Hamza" }
		  });
		  try { localStorage.setItem(STORAGE_KEY, JSON.stringify(data)); } catch {}
		}

		// Recharge les sélections et coche les bons boutons
		function loadSelections(){
		  let data;
		  try { data = JSON.parse(localStorage.getItem(STORAGE_KEY) || '{}'); } catch { data = {}; }
		  Object.entries(data).forEach(([name, val]) => {
			// coche la valeur sauvegardée si le bouton existe encore
			const sel = document.querySelector(
			  `#choix input[type="radio"][name="${CSS.escape(name)}"][value="${CSS.escape(val)}"]`
			);
			if (sel) {
			  sel.checked = true;
			  // visuel: applique la classe .selected comme quand on clique
			  const options = sel.closest('.options');
			  options?.querySelectorAll('label').forEach(l => l.classList.remove('selected'));
			  sel.closest('label')?.classList.add('selected');
			}
		  });
		}

		// Sauvegarde auto si l’utilisateur quitte la page
		window.addEventListener('beforeunload', saveSelections);

		// Sauvegarde à chaque changement de choix
		document.addEventListener('change', (e) => {
		  if (e.target.matches('#choix input[type=radio]')) {
			saveSelections();
		  }
		});


		// "21h15" ou "21:15" -> minutes depuis 00h00
		function toMin(str){
		  if (!str) return null;

		  // 1) "HHhMM" ou "HHh"
		  let m = str.match(/^(\d{1,2})h(\d{0,2})$/i);
		  if (m) {
			const h = parseInt(m[1],10);
			const min = m[2] ? parseInt(m[2],10) : 0;
			return h*60 + min;
		  }

		  // 2) "HH:MM"
		  m = str.match(/^(\d{1,2}):(\d{2})$/);
		  if (m) {
			const h = parseInt(m[1],10);
			const min = parseInt(m[2],10);
			return h*60 + min;
		  }

		  return null;
		}
		// minutes -> "21h15"
		function toHHmm(total){
		  const h = Math.floor(total/60);
		  const m = total%60;
		  return `${h}h${String(m).padStart(2,'0')}`;
		}
		// calcule [start,end] en minutes (gère la nuit : fin <= début -> +24h)
		function intervalFor(heureDebut, fin){
		  const s = toMin(heureDebut);
		  let e = fin ? toMin(fin) : (s != null ? s + 45 : null); // durée par défaut 45'
		  if (s != null && e != null && e <= s) e += 24 * 60;      // ← clé : passe-minuit
		  return [s, e];
		}
		// minutes de chevauchement (0 si aucun) — gère les slots qui passent minuit (déjà normalisés par intervalFor)
		function overlapMinutes(a, b){
		  const start = Math.max(a[0], b[0]);
		  const end   = Math.min(a[1], b[1]);
		  return Math.max(0, end - start);
		}

		function durationOf(range){ return range[1] - range[0]; }
		const WATCHABLE_MIN = 30;
		const ROLLOVER_MIN = 8 * 60;   // tout set qui commence avant 08:00 est considéré "lendemain"

		
		function overlapEdge(cur, other){
		  // chevauchement = [max(starts), min(ends)]
		  const ovStart = Math.max(cur[0], other[0]);
		  const ovEnd   = Math.min(cur[1], other[1]);
		  if (ovStart === other[0]) return 'début'; // chevauche le début de "other"
		  if (ovEnd   === other[1]) return 'fin';   // chevauche la fin de "other"
		  // sinon au milieu : on choisit le côté le plus proche pour rester lisible
		  return (ovStart - other[0]) <= (other[1] - ovEnd) ? 'début' : 'fin';
		}

		// Retourne pour un intervalle `cur` son "pire" restant vs une liste d'intervalles sélectionnés
		// => { minRemaining, dir }  dir ∈ {'avant','apres','mix','none'}
		function remainingVsSelected(cur, selectedRanges){
		  if (!selectedRanges.length) return { minRemaining: durationOf(cur), dir: 'none' };

		  let minRemaining = Infinity;
		  let dirForMin = 'mix';

		  for (const sel of selectedRanges){
			const ov = overlapMinutes(cur, sel.range);
			const remaining = durationOf(cur) - ov;

			// Détermination de la direction principale du restant vs ce `sel`
			let dir = 'mix';
			if (sel.range[1] <= cur[0]) {        // sel finit avant que cur commence
			  dir = 'avant';
			} else if (sel.range[0] >= cur[1]) { // sel commence après que cur finisse
			  dir = 'apres';
			} else {
			  // il y a recouvrement : on regarde où est la plus grosse "branche" restante
			  const avant = Math.max(0, cur[0] - sel.range[0]);
			  const apres = Math.max(0, sel.range[1] - cur[1]);
			  if (avant > apres) dir = 'avant';
			  else if (apres > avant) dir = 'apres';
			  else dir = 'mix';
			}

			if (remaining < minRemaining){
			  minRemaining = remaining;
			  dirForMin = dir;
			}
		  }
		  return { minRemaining: Math.max(0, minRemaining), dir: dirForMin };
		}


		// chevauchement strict (si b commence avant que a finisse ET b finit après que a commence)
		function overlap(a,b){ return a[0] < b[1] && b[0] < a[1]; }
		
		// Recalcule les conflits pour un jour donné (sans désactiver le clic)
		function updateConflictsForDay(jour){
		  // 1) Récupère tous les créneaux déjà sélectionnés (avec heures)
		  const selectedIntervals = [];
		  (donneesFestival[jour] || []).forEach(slot=>{
			const checked = document.querySelector(`input[name="${jour}_${slot.heure}"]:checked`);
			if (!checked || checked.value === "Aucun") return;
			const lab = checked.closest('.option');
			const s = parseInt(lab?.dataset.start ?? '', 10);
			const e = parseInt(lab?.dataset.end   ?? '', 10);
			if (!isNaN(s) && !isNaN(e)) selectedIntervals.push({range:[s,e], el:lab});
		  });

		  // 2) Réinitialise l'état visuel
		  document.querySelectorAll(`.option[data-jour="${jour}"]`).forEach(l=>{
			l.classList.remove('conflict');
		  });

			// 3) Marque en conflit/partiel ET écrit une note "Chevauche XX min début/fin de NOM"
			document.querySelectorAll(`.option[data-jour="${jour}"]`).forEach(l=>{
			  const inp = l.querySelector('input[type="radio"]');
			  const noteEl = l.querySelector('.ov-note');
			  if (noteEl) noteEl.textContent = ''; // reset note

			  if (!inp || inp.value === 'Aucun') return;

			  const s = parseInt(l.dataset.start ?? '', 10);
			  const e = parseInt(l.dataset.end   ?? '', 10);
			  if (isNaN(s) || isNaN(e)) return;

			  const cur = [s,e];
			  let maxOv = 0;
			  let worstRemaining = Infinity;
			  let worstDir = 'mix';
			  let bestOther = null; // label de l'autre show le plus "impactant"

			  for (const sel of selectedIntervals){
				if (sel.el === l) continue;
				const ov = overlapMinutes(cur, sel.range);
				if (ov > 0){
				  // suivi pour la note : garder celui avec le plus gros chevauchement
				  if (ov > maxOv){
					maxOv = ov;
					bestOther = sel.el; // label DOM de l’autre sélectionné
				  }
				  const rem = durationOf(cur) - ov;
				  if (rem < worstRemaining){
					worstRemaining = rem;
					// direction globale (avant/après/mix) – on la réutilise moins maintenant
					worstDir = remainingVsSelected(cur, [sel]).dir;
				  }
				}
			  }

			  l.classList.remove('conflict','partial');
			  delete l.dataset.remmin;
			  delete l.dataset.dir;

			  if (!selectedIntervals.length || maxOv === 0){
				return; // rien de choisi ou pas de recouvrement -> pas de badge/note
			  }

			  // Remplir la note lisible si on a un "other"
			  if (bestOther){
				const otherName = bestOther.querySelector('strong')?.textContent || 'autre show';
				const edge = overlapEdge(cur, [
				  parseInt(bestOther.dataset.start,10),
				  parseInt(bestOther.dataset.end,10)
				]);
				if (noteEl) noteEl.textContent = `Chevauche ${maxOv} min ${edge} de ${otherName}`;
			  }

			  // Décision visuelle: conflit si le "pire restant" < seuil, sinon partiel
			  if (worstRemaining < WATCHABLE_MIN){
				l.classList.add('conflict');
				l.dataset.remmin = String(Math.max(0, worstRemaining));
			  } else {
				l.classList.add('partial');
				l.dataset.remmin = String(Math.max(0, worstRemaining));
			  }
			});
		}

	  function demarrerChoix() {
		joursChoisis = Array.from(document.querySelectorAll('#selection-jours input[type=checkbox]:checked')).map(cb => cb.value);
		document.getElementById('selection-jours').classList.add('hidden');
		genererChoix();
	  }

		function genererChoix() {
		  const choixDiv = document.getElementById('choix');
		  choixDiv.innerHTML = '';

		  joursChoisis.forEach(jour => {
			const jourDiv = document.createElement('div');
			jourDiv.classList.add('day-group');
			jourDiv.innerHTML = `<h3>${jour}</h3>`;
			if (!donneesFestival[jour]) return;

			// 1) TRI avec “après-minuit => +24h”
			const slots = [...donneesFestival[jour]].sort((a, b) => {
			  const sa = toMin(a.heure);
			  const sb = toMin(b.heure);
			  const na = (sa != null && sa < ROLLOVER_MIN) ? sa + 24*60 : sa;
			  const nb = (sb != null && sb < ROLLOVER_MIN) ? sb + 24*60 : sb;
			  return (na ?? 0) - (nb ?? 0);
			});

			// 2) Construction UI UNIQUEMENT à partir de `slots`
			slots.forEach(slot => {
			  const slotDiv = document.createElement('div');
			  slotDiv.className = 'slot';

			  const hEl = document.createElement('div');
			  hEl.className = 'heure';
			  hEl.textContent = slot.heure || '';
			  slotDiv.appendChild(hEl);

			  const options = document.createElement('div');
			  options.className = 'options';
			  const groupName = `${jour}_${slot.heure}`;

			  // "Aucun" (par défaut sélectionné)
			  const optNone = document.createElement('label');
			  optNone.className = 'option option-none selected';
			  optNone.innerHTML = `
				<input type="radio" name="${groupName}" value="Aucun" checked>
				<strong>Aucun</strong>
				<small>—</small>
			  `;
			  options.appendChild(optNone);

			  // Artistes
			  (slot.artistes || []).forEach((a, idx) => {
				const [sMin, eMin] = intervalFor(slot.heure, a.fin);
				const endStr = (eMin != null)
				  ? toHHmm(eMin % (24*60))
				  : (toMin(slot.heure) != null ? toHHmm((toMin(slot.heure)+45) % (24*60)) : "");

				const id = `${groupName}_art${idx}`;
				const opt = document.createElement('label');
				opt.className = 'option';

				// normalisation "lendemain"
				let sNorm = sMin, eNorm = eMin;
				if (sNorm != null && sNorm < ROLLOVER_MIN) { sNorm += 24*60; eNorm += 24*60; }

				opt.dataset.jour  = jour;
				opt.dataset.start = sNorm ?? '';
				opt.dataset.end   = eNorm ?? '';

				opt.innerHTML = `
				  <input type="radio" id="${id}" name="${groupName}" value="${a.nom}">
				  <strong>${a.nom}</strong>
				  <small>${a.style} <span style="opacity:.6">•</span> ${a.scene}<br>
				  <span class="time">${slot.heure}${endStr ? '–'+endStr : ''}</span></small>
				`;
				const note = document.createElement('div');
				note.className = 'ov-note';
				opt.appendChild(note);

				options.appendChild(opt);
			  });

			  slotDiv.appendChild(options);
			  jourDiv.appendChild(slotDiv);
			});

			choixDiv.appendChild(jourDiv);
		  });

		  // 3) Bouton unique “Valider mes choix”
		  const validateBtn = document.createElement('button');
		  validateBtn.type = 'button';
		  validateBtn.textContent = 'Valider mes choix';
		  validateBtn.addEventListener('click', afficherResultats);
		  choixDiv.appendChild(validateBtn);

		  // 4) Premier calcul de conflits
		  loadSelections();          // <-- recharge les choix depuis la mémoire
		  recomputeAllConflicts();

		  choixDiv.classList.remove('hidden');
		}


		function afficherResultats() {
		  const resultatsDiv = document.getElementById('resultats');
		  const listeResultats = document.getElementById('liste-resultats');

		  // Nettoyage
		  listeResultats.innerHTML = '';
		  resultatsDiv.querySelectorAll('.back-btn').forEach(btn => btn.remove());

		  // Styles du tableau (fond blanc + lignes violettes)
		  const cellStyle   = 'border: 1px solid #8000ff; padding: 8px; font-size: 1em; color: #111; background-color: #ffffff;';
		  const headerStyle = 'border: 1px solid #8000ff; padding: 8px; font-size: 1em; font-weight: bold; background-color: #8000ff; color: #ffffff;';

		  joursChoisis.forEach(jour => {
			if (!donneesFestival[jour]) return;

			// ---- Conteneur de jour
			const section = document.createElement('section');
			section.className = 'jour-section';

			// ---- Titre de jour
			const titre = document.createElement('h2');
			titre.className = 'jour-titre';
			titre.textContent = jour;
			section.appendChild(titre);

			// ---- Récupère les choix sélectionnés (avec heures)
			const selected = [];
			(donneesFestival[jour] || []).forEach(slot => {
			  const checked = document.querySelector(`input[name="${jour}_${slot.heure}"]:checked`);
			  if (!checked || checked.value === "Aucun") return;
			  const artiste = slot.artistes.find(a => a.nom === checked.value);
			  if (!artiste) return;

			  const [sMin, eMin] = intervalFor(slot.heure, artiste.fin);

			  // normalisation "lendemain" pour l’ordre et la timeline
			  let sNorm = sMin, eNorm = eMin;
			  if (sNorm != null && sNorm < ROLLOVER_MIN) { sNorm += 24*60; eNorm += 24*60; }

			  selected.push({
				start: sNorm, end: eNorm,          // ← normalisé pour TRI & TIMELINE
				debutStr: slot.heure,
				finStr: toHHmm(eMin % (24*60)),    // ← affichage humain (00h15, 01h00…)
				nom: artiste.nom, scene: artiste.scene, style: artiste.style
			  });
			});

			// Rien de sélectionné pour ce jour
			if (!selected.length){
			  const p = document.createElement('p');
			  p.textContent = "Aucun choix validé pour ce jour.";
			  section.appendChild(p);
			  listeResultats.appendChild(section);
			  return;
			}

			// ---- Tri par début
			selected.sort((a,b)=>a.start-b.start);

			// ---- Calcul des notes et du statut (partial / conflict)
			const WATCHABLE_MIN = 30;
			function overlapMinutes(a,b){
			  const st = Math.max(a.start, b.start);
			  const en = Math.min(a.end,   b.end);
			  return Math.max(0, en - st);
			}
			function durationOf(x){ return x.end - x.start; }
			function overlapEdge(cur, other){
			  const ovStart = Math.max(cur.start, other.start);
			  const ovEnd   = Math.min(cur.end,   other.end);
			  if (ovStart === other.start) return 'début';
			  if (ovEnd   === other.end)   return 'fin';
			  return (ovStart - other.start) <= (other.end - ovEnd) ? 'début' : 'fin';
			}

			const enriched = selected.map((cur, idx)=>{
			  let maxOv = 0, bestOtherIndex = -1, worstRemaining = durationOf(cur);
			  for (let j=0;j<selected.length;j++){
				if (j===idx) continue;
				const other = selected[j];
				const ov = overlapMinutes(cur, other);
				if (ov>0){
				  if (ov>maxOv){ maxOv = ov; bestOtherIndex = j; }
				  const remaining = durationOf(cur) - ov;
				  if (remaining < worstRemaining) worstRemaining = remaining;
				}
			  }
			  let status = null, note = "";
			  if (maxOv>0 && bestOtherIndex>=0){
				const other = selected[bestOtherIndex];
				const edge = overlapEdge(cur, other);
				status = (worstRemaining < WATCHABLE_MIN) ? 'conflict' : 'partial';
				note = `Chevauche ${maxOv} min ${edge} de ${other.nom}`;
			  }
			  return {...cur, status, note};
			});

			// ---- Mini-timeline: échelle commune
			const minStart = Math.min(...enriched.map(x=>x.start));
			const maxEnd   = Math.max(...enriched.map(x=>x.end));
			const span     = Math.max(1, maxEnd - minStart);

			// ---- Création du tableau
			const table = document.createElement('table');

			// Largeurs de colonnes (début, fin, artiste, scène, style, note, timeline)
			table.innerHTML = `
			  <colgroup>
				<col style="width:6.5%">
				<col style="width:6.5%">
				<col style="width:22%">
				<col style="width:15%">
				<col style="width:16%">
				<col style="width:18%">
				<col style="width:15%">
			  </colgroup>
			`;

			// En-têtes
			const headerRow = document.createElement('tr');
			['Début','Fin','Artiste','Scène','Style','Note','Timeline'].forEach((text, idx) => {
			  const th = document.createElement('th');
			  th.style.cssText = headerStyle;
			  th.textContent = text;
			  if (idx === 4) th.classList.add('col-style'); // 5e colonne = Style
			  headerRow.appendChild(th);
			});

			table.appendChild(headerRow);

			// Lignes
			enriched.forEach(item=>{
			  const tr = document.createElement('tr');

			// Début
			let td = document.createElement('td');
			td.style.cssText = cellStyle;
			td.classList.add('nowrap');
			td.textContent = item.debutStr;
			tr.appendChild(td);

			// Fin
			td = document.createElement('td');
			td.style.cssText = cellStyle;
			td.classList.add('nowrap');
			td.textContent = item.finStr;
			tr.appendChild(td);

			// Artiste
			td = document.createElement('td'); td.style.cssText = cellStyle; td.textContent = item.nom; tr.appendChild(td);

			// Scène
			td = document.createElement('td'); td.style.cssText = cellStyle; td.textContent = item.scene; tr.appendChild(td);

			// Style  ← on marque la colonne pour pouvoir la masquer en PDF si voulu
			td = document.createElement('td'); td.style.cssText = cellStyle; td.classList.add('col-style'); td.textContent = item.style; tr.appendChild(td);

			// Note (badge)
			td = document.createElement('td');
			td.style.cssText = cellStyle;
			td.classList.add('col-note');        // <-- important
			if (item.note){
			  const b = document.createElement('span');
			  b.className = 'note-badge ' + (item.status || 'partial');
			  b.textContent = item.note;
			  td.appendChild(b);
			}
			tr.appendChild(td);



			  td = document.createElement('td'); td.style.cssText = cellStyle;
			  const tl = document.createElement('div'); tl.className='tl-cell';
			  const bar = document.createElement('div'); bar.className='tl-range';
			  const leftPct  = ((item.start - minStart) / span) * 100;
			  const widthPct = ((item.end   - item.start) / span) * 100;
			  bar.style.left  = leftPct.toFixed(2) + '%';
			  bar.style.width = widthPct.toFixed(2) + '%';
			  const label = document.createElement('div'); label.className='tl-label';
			  label.textContent = `${item.debutStr}–${item.finStr}`;
			  tl.appendChild(bar); tl.appendChild(label);
			  td.appendChild(tl);
			  tr.appendChild(td);

			  table.appendChild(tr);
			});

			// ✅ maintenant on place le tableau dans la section, puis la section dans la liste
			section.appendChild(table);
			listeResultats.appendChild(section);
		  });

		  // Bouton retour (unique)
		  const backBtn = document.createElement('button');
		  backBtn.type = 'button';
		  backBtn.className = 'back-btn';
		  backBtn.textContent = 'Revenir aux choix';
		  backBtn.addEventListener('click', revenirAuxChoix);
		  resultatsDiv.appendChild(backBtn);

		  document.getElementById('choix').classList.add('hidden');
		  resultatsDiv.classList.remove('hidden');
		}

	  function revenirAuxChoix() {
		const res = document.getElementById('resultats');
		res.querySelectorAll('.back-btn').forEach(btn => btn.remove());
		res.classList.add('hidden');
		document.getElementById('choix').classList.remove('hidden');
	  }

		async function genererPDF() {
		  const { jsPDF } = window.jspdf;

		  // 👉 portrait ('p') ou paysage ('l')
		  const doc = new jsPDF('l', 'pt', 'a4');

		  const pageW   = doc.internal.pageSize.getWidth();
		  const pageH   = doc.internal.pageSize.getHeight();
		  const margin  = 28;
		  const headH   = 18;                     // hauteur réservée au titre par page
		  const contW   = pageW - margin * 2;     // zone utile (largeur)
		  const contH   = pageH - margin * 2 - headH; // zone utile (hauteur sous le titre)
		  const safeWpx = Math.floor(contW - 10); // marge anti-rognage pour la capture

		  document.body.classList.add('pdf-mode');

		  try {
			const sections = Array.from(document.querySelectorAll('#liste-resultats .jour-section'));
			if (!sections.length) {
			  alert("Aucun résultat à exporter.");
			  return;
			}

			for (const section of sections) {
			  // -------- Prépare la capture
			  const prev = { width: section.style.width, maxWidth: section.style.maxWidth };
			  section.style.width = safeWpx + 'px';
			  section.style.maxWidth = safeWpx + 'px';

			  // Capture HD
			  const canvas = await html2canvas(section, {
				backgroundColor: '#ffffff',
				scale: 2,
				useCORS: true,
				windowWidth: safeWpx
			  });

			  // Restaure styles
			  section.style.width = prev.width;
			  section.style.maxWidth = prev.maxWidth;

			  // -------- Calcule les points de coupe alignés sur les <tr>
			  // Facteur DOM -> Canvas
			  const scaleDomToCanvas = canvas.width / section.clientWidth;

			  // Limite de hauteur par page en PIXELS CANVAS
			  const scalePdf   = (contW - 10) / canvas.width;
			  const maxSlicePx = Math.floor(contH / scalePdf);

			  // Collecte des bas de <tr> (en px canvas, relatifs au haut de la section)
			  const sectionRect = section.getBoundingClientRect();
			  const cuts = [0]; // début
			  section.querySelectorAll('table').forEach(tbl => {
				tbl.querySelectorAll('tr').forEach(tr => {
				  const r = tr.getBoundingClientRect();
				  const bottomRelDom = r.bottom - sectionRect.top;          // px DOM
				  const bottomRelCv  = Math.floor(bottomRelDom * scaleDomToCanvas); // px canvas
				  if (bottomRelCv > 0 && bottomRelCv < canvas.height) cuts.push(bottomRelCv);
				});
			  });
			  cuts.push(canvas.height); // fin

				// Détermine les tranches (pages) : on prend le DERNIER repère <= fenêtre
				const slices = [];
				let cur = 0;
				while (cur < canvas.height) {
				  const target = cur + maxSlicePx;

				  // Tous les repères > cur et ≤ target
				  const candidates = cuts.filter(c => c > cur && c <= target);

				  let next;
				  if (candidates.length) {
					// on prend le plus grand (dernier) -> page bien remplie
					next = candidates[candidates.length - 1];
				  } else {
					// pas de repère dans la fenêtre : on cherche le premier repère après target
					next = cuts.find(c => c > target) ?? canvas.height;
				  }

				  if (next <= cur) next = Math.min(cur + maxSlicePx, canvas.height);

				  slices.push([cur, next - cur]);
				  cur = next;
				}


			  // -------- Ajoute les pages avec header
			  const dayTitle = section.querySelector('.jour-titre')?.textContent?.trim() || 'Jour';
			  const totalPages = slices.length;

			  // Canvas pour découpe
			  const slicer = document.createElement('canvas');
			  const sctx   = slicer.getContext('2d', { willReadFrequently: true });
			  slicer.width = canvas.width;

			  slices.forEach(([y, h], idx) => {
				slicer.height = h;
				sctx.clearRect(0, 0, slicer.width, slicer.height);
				sctx.drawImage(canvas, 0, y, canvas.width, h, 0, 0, slicer.width, h);

				const imgData = slicer.toDataURL('image/jpeg', 0.92);

				// Header
				const pageLabel = `${dayTitle} — page ${idx + 1}/${totalPages}`;
				doc.setFont('helvetica', 'bold');
				doc.setFontSize(11);
				doc.text(pageLabel, margin, margin + 10);

				// Image (sous le header)
				const imgW = contW - 10;
				const imgH = h * ((contW - 10) / canvas.width);
				doc.addImage(imgData, 'JPEG', margin, margin + headH, imgW, imgH);

				// Page suivante si ce n'est pas la dernière
				if (idx < slices.length - 1) doc.addPage();
			  });

			  // Page blanche entre les jours (sauf après le dernier jour)
			  if (section !== sections[sections.length - 1]) doc.addPage();
			}

			doc.save('RunningOrder.pdf');

		  } catch (err) {
			console.error('Erreur PDF:', err);
			alert('La génération du PDF a échoué (voir console).');
		  } finally {
			document.body.classList.remove('pdf-mode');
		  }
		}

		document.addEventListener('change', (e) => {
		  if (!e.target.matches('.option input[type="radio"]')) return;

		  const input = e.target;
		  const group = input.name;                 // ex: "Vendredi_23h15"
		  const jour  = group.split('_')[0];        // "Vendredi"

		  // 1) Visuel "selected" dans le groupe courant
		  document.querySelectorAll(`input[name="${group}"]`).forEach(inp => {
			const card = inp.closest('.option');
			if (card) card.classList.toggle('selected', inp.checked && inp === input);
		  });

		  // 2) Si on a choisi un ARTISTE (pas "Aucun"), on ne désélectionne les autres
		  //    que si EUX n'ont plus assez de "restant" (< WATCHABLE_MIN)
		  const curLabel = input.closest('.option');
		  const s = parseInt(curLabel?.dataset.start || '', 10);
		  const eEnd = parseInt(curLabel?.dataset.end   || '', 10);

		  if (input.value !== 'Aucun' && !isNaN(s) && !isNaN(eEnd)) {
			const curRange = [s, eEnd];

			// Parcourt tous les autres créneaux choisis de ce jour
			(donneesFestival[jour] || []).forEach(slot => {
			  const gname = `${jour}_${slot.heure}`;
			  if (gname === group) return; // pas le créneau courant

			  const checked = document.querySelector(`input[name="${gname}"]:checked`);
			  if (!checked || checked.value === 'Aucun') return;

			  const lab = checked.closest('.option');
			  const s2 = parseInt(lab?.dataset.start || '', 10);
			  const e2 = parseInt(lab?.dataset.end   || '', 10);
			  if (isNaN(s2) || isNaN(e2)) return;

			  const otherRange = [s2, e2];
			  const ov = overlapMinutes(curRange, otherRange);

				if (ov > 0){
				  const remainingOther = durationOf(otherRange) - ov;
				  const remainingNew   = durationOf(curRange)  - ov;

				  // Nouvelle règle :
				  // - si le NOUVEAU garde >= seuil (ex. 30'), on autorise la cohabitation (on ne touche pas à l'autre)
				  // - si chacun garde >= seuil -> cohabitation aussi
				  // - on ne dé-sélectionne l'autre QUE si LES DEUX < seuil → on garde le nouveau, on met l'autre à "Aucun"
				  if (remainingNew < WATCHABLE_MIN && remainingOther < WATCHABLE_MIN){
					const none = document.querySelector(`input[name="${gname}"][value="Aucun"]`);
					if (none) {
					  none.checked = true;
					  document.querySelectorAll(`input[name="${gname}"]`).forEach(inp => {
						const c = inp.closest('.option');
						if (c) c.classList.toggle('selected', inp.checked);
					  });
					}
				  }
				}
			});
		  }

		  // 3) Recalcule l’habillage de conflit/partiel pour le jour
		  updateConflictsForDay(jour);
		});


		// Recalcule tous les jours sélectionnés
		function recomputeAllConflicts(){
		  (joursChoisis || []).forEach(updateConflictsForDay);
		}
		
	window.addEventListener('DOMContentLoaded', () => {
	  const start = document.getElementById('btnStart');
	  if (start) start.addEventListener('click', demarrerChoix);
	  
	// --- Bouton "Effacer mes choix mémorisés" ---
	document.getElementById('btnResetMem')?.addEventListener('click', () => {
	  localStorage.removeItem(STORAGE_KEY);
	  // Remet "Aucun" partout
	  document.querySelectorAll('#choix .option-none input[type=radio]').forEach(r => r.checked = true);
	  document.querySelectorAll('#choix .options label').forEach(l => l.classList.remove('selected'));
	  document.querySelectorAll('#choix .option-none').forEach(l => l.classList.add('selected'));
	  saveSelections();
	  recomputeAllConflicts();
	});
 
});


  </script>

</body>
</html>
