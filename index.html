<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title> Choisis ton Running Order - Dream Nation</title>
  <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;600;800&display=swap" rel="stylesheet">
  <style>
:root{
  --bg: #0a0a0f;
  --bg2:#0e0e16;
  --text:#e9eef2;
  --muted:#9aa3ab;
  --card:#12121c;
  --stroke:#222334;
  --accent1:#ff00e6;   /* magenta */
  --accent2:#00e5ff;   /* cyan */
  --gold:#FFD700;      /* pour ton PDF / tableaux */
}

*{box-sizing:border-box}
html,body{margin:0}
body{
  background:
    radial-gradient(1200px 600px at 10% -10%, #11131f 0%, transparent 60%),
    radial-gradient(1000px 500px at 110% 10%, #0f1130 0%, transparent 60%),
    linear-gradient(180deg, var(--bg) 0%, var(--bg2) 100%);
  color:var(--text);
  font-family: "Montserrat", system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
  text-align:center;
  padding:28px 20px 40px;
}

/* Titres */
h1{
  margin:0 0 12px;
  font-weight:800; letter-spacing:.5px;
  text-transform:uppercase;
  background: linear-gradient(90deg, var(--accent1), var(--accent2));
  -webkit-background-clip:text; background-clip:text; color:transparent;
  text-shadow: 0 0 16px rgba(255,0,230,.15), 0 0 18px rgba(0,229,255,.12);
}

.day-group{margin:36px auto 28px; max-width:1100px; text-align:left;}
.day-group h3{
  margin:0 0 14px; padding:0 2px;
  font-size:20px; font-weight:800; letter-spacing:.5px; text-transform:uppercase;
  color:#fff;
  position:relative;
}
.day-group h3::after{
  content:"";
  display:block; height:3px; margin-top:8px; border-radius:3px;
  background:linear-gradient(90deg,var(--accent1),var(--accent2));
  box-shadow: 0 0 18px rgba(255,0,230,.35), 0 0 22px rgba(0,229,255,.3);
}

/* Boutons */
button{
  font-size:15px; font-weight:700; letter-spacing:.3px; text-transform:uppercase;
  padding:12px 18px; border:none; border-radius:12px; cursor:pointer;
  color:#081018;
  background:linear-gradient(90deg, var(--accent1), var(--accent2));
  box-shadow: 0 8px 24px rgba(0,229,255,.18), inset 0 0 0 1px rgba(255,255,255,.06);
  transition: transform .08s ease, box-shadow .2s ease, filter .2s ease;
}
button:hover{ transform: translateY(-1px); filter:brightness(1.05); }
button:active{ transform: translateY(0); }

/* Grille des créneaux */
.slot{
  display:flex; flex-direction:column; gap:12px;
  max-width:1000px; margin:16px auto; text-align:left;
  padding-left:12px; border-left:3px solid transparent;
  border-image: linear-gradient(180deg, var(--accent1), var(--accent2)) 1;
}
.slot .heure{
  font-weight:800; letter-spacing:.5px;
  color:#fff; opacity:.95;
}

/* Conteneur des options : en flex, retour à la ligne */
.slot .options{
  display:flex;
  flex-wrap:wrap;
  gap:12px;
}

/* Les cartes artistes s'adaptent, mais jamais trop petites */
.option{
  flex:1 1 280px; /* ← largeur mini 280px, s'étire sinon */
}


/* Cartes cliquables (glass) */
.option{
  position:relative;
  border:1px solid var(--stroke);
  background: linear-gradient(180deg, rgba(255,255,255,.02), rgba(255,255,255,.01));
  border-radius:16px; padding:12px 14px; cursor:pointer;
  transition: border-color .15s, box-shadow .15s, background .15s, transform .05s;
}
.option:hover{ border-color:#2d2f45; background:rgba(255,255,255,.03); }
.option strong{ display:block; font-weight:800; color:#fff; }
.option small { display:block; margin-top:4px; color:var(--muted); }

/* cacher le radio */
.option input[type="radio"]{
  position:absolute; opacity:0; width:0; height:0; pointer-events:none;
}

/* état sélectionné via :has (modern) + fallback .selected */
.option:has(input[type="radio"]:checked),
.option.selected{
  border-color:transparent;
  background: rgba(10,20,30,.25);
  box-shadow:
    0 0 0 1px rgba(255,255,255,.06) inset,
    0 0 24px rgba(255,0,230,.20),
    0 0 28px rgba(0,229,255,.18);
}
.option:has(input[type="radio"]:checked) strong,
.option:has(input[type="radio"]:checked) small,
.option.selected strong,
.option.selected small{
  color:#e8fbff;
  text-shadow: 0 0 10px rgba(0,229,255,.25);
}

/* Résultats */
#resultats h2{
  text-transform:uppercase; letter-spacing:.5px;
}

table {
  background: #0d1117;
  border-radius: 14px;
  overflow: hidden;
  color: #fff;
  border-collapse: collapse;
  font-family: Montserrat, sans-serif;
  font-size: 12px;
}
th {
  background: linear-gradient(90deg, #ff00e6, #00e5ff);
  color: #fff;
  text-transform: uppercase;
  font-size: 13px;
  padding: 8px;
}
td {
  border: 1px solid #333;
  padding: 8px;
}


/* Mobile */
@media (max-width:740px){
  body{ padding:18px 14px 28px; }
}

.hidden {
  display: none;
}

#liste-resultats table td,
#liste-resultats table th {
  box-shadow: 0 0 6px rgba(128,0,255,0.6);
}

.jour-titre {
  margin: 40px 0 10px;
  font-size: 2.2em;
  font-weight: 900;
  text-transform: uppercase;
  letter-spacing: 2px;
  text-align: center;
  background: linear-gradient(90deg, #ff00e6, #00e5ff);
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  background-clip: text;
  text-fill-color: transparent;
  text-shadow: 0 0 18px rgba(255,0,230,0.25),
               0 0 22px rgba(0,229,255,0.25);
  position: relative;
  display: inline-block;
  padding-bottom: 10px;
}

.jour-titre::after {
  content: "";
  display: block;
  height: 4px;
  margin: 10px auto 0;
  width: 80%;
  max-width: 400px;
  border-radius: 2px;
  background: linear-gradient(90deg, #ff00e6, #00e5ff);
  box-shadow: 0 0 12px rgba(255,0,230,.6), 0 0 16px rgba(0,229,255,.6);
}


.jour-titre {
  margin: 40px 0 20px;
  font-size: 2.2em;
  font-weight: 900;
  text-transform: uppercase;
  letter-spacing: 2px;
  text-align: center;
  color: #fff;

  background: linear-gradient(90deg, #ff00e6, #00e5ff);
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  background-clip: text;
  text-fill-color: transparent;

  text-shadow: 0 0 18px rgba(255,0,230,0.25),
               0 0 22px rgba(0,229,255,0.25);
}

.option-none {
  width: 120px;      /* largeur fixe */
  height: 70px;      /* hauteur fixe */
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
  text-align: center;
}

.option-none strong {
  font-size: 14px;
}

.option-none small {
  display: none; /* inutile pour "Aucun" */
}

.option.selected {
  border-color: transparent;
  background: rgba(10,20,30,.45);
  box-shadow: 0 0 18px rgba(255,0,230,.35), 0 0 22px rgba(0,229,255,.35);
}

.option.selected strong {
  color: #ff00e6; /* texte principal néon rose */
}

.option.selected small {
  color: #00e5ff; /* sous-texte en cyan */
}

/* Couleurs du texte quand sélectionné */
.option.selected strong { color:#ff00e6 !important; }  /* rose néon */
.option.selected small  { color:#00e5ff !important; }  /* cyan */

/* Si le navigateur supporte :has, colorer aussi via :has() */
.option:has(input[type="radio"]:checked) strong { color:#ff00e6 !important; }
.option:has(input[type="radio"]:checked) small  { color:#00e5ff !important; }

/* Pulse néon doux sur l'option sélectionnée */
@keyframes neonPulse{
  0%,100%{
    box-shadow:
      0 0 0 1px rgba(255,255,255,.06) inset,
      0 0 18px rgba(255,0,230,.28),
      0 0 22px rgba(0,229,255,.26);
  }
  50%{
    box-shadow:
      0 0 0 1px rgba(255,255,255,.08) inset,
      0 0 28px rgba(255,0,230,.45),
      0 0 34px rgba(0,229,255,.42);
  }
}

/* Appliquer le pulse uniquement à l'état sélectionné */
.option.selected,
.option:has(input[type="radio"]:checked){
  animation: neonPulse 1.6s ease-in-out infinite;
}

/* Respecte la préférence "réduire les animations" */
@media (prefers-reduced-motion: reduce){
  .option.selected,
  .option:has(input[type="radio"]:checked){
    animation: none;
  }
}

/* Affichage de l'intervalle */
.option .time { opacity:.9; }

/* Afficher clairement les conflits horaires */
.option.conflict{
  opacity:.45;
  filter: grayscale(.15);
  position: relative;
}
.option.conflict::after{
  content:"Conflit horaire";
  position:absolute; top:8px; right:12px;
  font-size:11px; padding:2px 6px; border-radius:999px;
  background: rgba(255,0,230,.18);
  color:#ff8ae8;
  border:1px solid rgba(255,0,230,.35);
}
.option.conflict input{ pointer-events:auto; }

/* Partiel : autorisé, affiche "Restant XX min avant/après" */
.option.partial{
  opacity:.9;
  position: relative;
  outline: 1px dashed rgba(255,165,0,.35);
}
.option.partial::after{
  content: "Restant " attr(data-remmin) " min " attr(data-dir);
  position:absolute; top:8px; right:12px;
  font-size:11px; padding:2px 6px; border-radius:999px;
  background: rgba(255,165,0,.18);
  color:#ffb84d;
  border:1px solid rgba(255,165,0,.35);
}

/* Conflit dur : moins de WATCHABLE_MIN */
.option.conflict{
  opacity:.6;
  filter: grayscale(.15);
  position: relative;
}
.option.conflict::after{
  content:"Restant " attr(data-remmin) " min " attr(data-dir) " (conflit)";
  position:absolute; top:8px; right:12px;
  font-size:11px; padding:2px 6px; border-radius:999px;
  background: rgba(255,0,230,.18);
  color:#ff8ae8;
  border:1px solid rgba(255,0,230,.35);
}
/* Petite ligne d’info sur le chevauchement */
.option .ov-note{
  margin-top: 6px;
  font-size: 11px;
  line-height: 1.25;
  color: #cfcfe6;
  opacity: .9;
}
.option.partial .ov-note{ color:#ffb84d; }     /* partiel = orange */
.option.conflict .ov-note{ color:#ff8ae8; }    /* conflit dur = rose */

/* Badge de note dans le tableau */
.note-badge{
  display:inline-block;
  font-size:11px;
  padding:2px 8px;
  border-radius:999px;
  border:1px solid;
  white-space:nowrap;
}
.note-badge.partial{
  color:#ffb84d; background:rgba(255,165,0,.12); border-color:rgba(255,165,0,.35);
}
.note-badge.conflict{
  color:#ff8ae8; background:rgba(255,0,230,.12); border-color:rgba(255,0,230,.35);
}

/* Mini timeline */
.tl-cell{
  width:260px; height:22px; position:relative;
  background:#f5f7fa; border:1px solid #e2e8f0; border-radius:6px;
  overflow:hidden;
}
.tl-range{
  position:absolute; top:0; bottom:0; border-radius:6px;
  background: linear-gradient(90deg, #ff00e6, #00e5ff);
  opacity:.85;
}
.tl-label{
  position:absolute; inset:0; display:flex; align-items:center; justify-content:center;
  font-size:11px; color:#0b1320; font-weight:700; mix-blend:normal;
}

  </style>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
</head>
<body>
  <h1>🎺 Fais ton choix pour chaque créneau</h1>

  <div id="selection-jours">
    <p>Quels jours fais-tu au festival ?</p>
    <label><input type="checkbox" value="Vendredi 26" checked> Vendredi</label><br>
    <label><input type="checkbox" value="Samedi 27" checked> Samedi</label><br>
    <button id="btnStart" type="button">Commencer</button>
  </div>

  <div id="choix" class="hidden"></div>
  <div id="resultats" class="hidden">
  <h2>🎉 Ton Running Order</h2>
  <ul id="liste-resultats"></ul>
  <button onclick="genererPDF()">📅 Télécharger en PDF</button>
</div>



  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
  <script>
	  let joursChoisis = [];

	  /* --- GARDE ICI TON OBJET donneesFestival TEL QUEL --- */
		let donneesFestival = {
		  "Samedi 27": [
		  		{ heure: "20h30", artistes: [
				  { nom: "HIBI", style: "Trancy/Groovy", scene: "Organik Stage", fin: "22h00" },
				]},
				{ heure: "21h00", artistes: [
				  { nom: "ASDEK", style: "Bass House", scene: "Bassquake Stage", fin: "21h45" },
				]},
				{ heure: "21h10", artistes: [
				  { nom: "HILIGHT TRIBE", style: "Trance / Tribal (Live)", scene: "Lunar Stage", fin: "22h40" },
				]},
				{ heure: "21h45", artistes: [
				  { nom: "MALAA × ALTER EGO", style: "House / Bass House", scene: "Bassquake Stage", fin: "23h15" },
				]},
				{ heure: "22h00", artistes: [
				  { nom: "PEAKSOU", style: "Trance/Hypertechno", scene: "Organik Stage", fin: "23h00" },
				]},
				{ heure: "23h00", artistes: [
				  { nom: "PERCEVAL", style: "Psytrance", scene: "Lunar Stage", fin: "23h55" },
				  { nom: "MANIL", style: "Hard Techno/Groove", scene: "Organik Stage", fin: "00h00" },
				]},
				{ heure: "23h15", artistes: [
				  { nom: "ZOMBOY", style: "Dubstep", scene: "Bassquake Stage", fin: "00h15" },
				]},
				{ heure: "00h00", artistes: [
				  { nom: "LB AKA LABAT", style: "Electro / House", scene: "Lunar Stage", fin: "1h00" },
				  { nom: "25EMEHEURE", style: "Hard Techno", scene: "Organik Stage", fin: "1h30" },
				]},
				{ heure: "00h15", artistes: [
				  { nom: "WILKINSON", style: "Drum & Bass", scene: "Bassquake Stage", fin: "1h15" },
				]},
				{ heure: "1h00", artistes: [
				  { nom: "FUNK TRIBU b2b MISCHLUFT", style: "Techno", scene: "Lunar Stage", fin: "2h15" },
				]},
				{ heure: "1h15", artistes: [
				  { nom: "ANDY C", style: "Drum & Bass", scene: "Bassquake Stage", fin: "2h15" },
				]},
				{ heure: "1h30", artistes: [
				  { nom: "NØNAME", style: "Techno / Electro", scene: "Organik Stage", fin: "3h00" },
				]},
				{ heure: "2h15", artistes: [
				  { nom: "VINI VICI", style: "Psytrance", scene: "Lunar Stage", fin: "3h15" },
				  { nom: "KAYZO b2b MUST DIE!", style: "Bass / Hard Dance / Dubstep", scene: "Bassquake Stage", fin: "3h15" },
				]},
				{ heure: "3h00", artistes: [
				  { nom: "BALAGAN", style: "Techno", scene: "Organik Stage", fin: "4h00" },
				]},
				{ heure: "3h15", artistes: [
				  { nom: "ASTRIX", style: "Psytrance", scene: "Lunar Stage", fin: "4h15" },
				  { nom: "KANINE b2b SOTA", style: "Drum & Bass", scene: "Bassquake Stage", fin: "4h15" },
				]},
				{ heure: "4h00", artistes: [
				  { nom: "OBSTN", style: "Techno", scene: "Organik Stage", fin: "5h00" },
				]},
				{ heure: "4h15", artistes: [
				  { nom: "ACE VENTURA", style: "Progressive Psytrance", scene: "Lunar Stage", fin: "5h15" },
				  { nom: "INFEKT b2b SAMPLIFIRE", style: "Riddim / Dubstep", scene: "Bassquake Stage", fin: "5h15" },
				]},
				{ heure: "5h00", artistes: [
				  { nom: "RHADAMANTHE", style: "Techno", scene: "Organik Stage", fin: "6h00" },
				]},
				{ heure: "5h15", artistes: [
				  { nom: "MANDIDEXTROUS", style: "Jungle / 160-170", scene: "Bassquake Stage", fin: "6h15" },
				  { nom: "EARGASM GOD", style: "Techno", scene: "Lunar Stage", fin: "6h15" },
				]},
		  ],
		  "Vendredi 26": [
		  		{ heure: "21h00", artistes: [
				  { nom: "SKONE & PROTOSKEED present SILENCE", style: "Tekno", scene: "Warzone Stage", fin: "22h00" },
				  { nom: "NICE KEED", style: "Fast & Hard Techno", scene: "Pulsar Stage", fin: "22h15" },
				]},
				{ heure: "22h00", artistes: [
				  { nom: "SPICE UP!", style: "Tekno", scene: "Warzone Stage", fin: "23h00" },
				  { nom: "LUX", style: "Hard Trance", scene: "2much stage", fin: "23h30" },
				]},
				{ heure: "22h15", artistes: [
				  { nom: "ZORZA", style: "Hyper Techno", scene: "Pulsar Stage", fin: "23h15" },
				]},
				{ heure: "23h00", artistes: [
				  { nom: "MAD DOG", style: "Hardcore italien", scene: "Warzone Stage", fin: "23h45" },
				]},
				{ heure: "23h15", artistes: [
				  { nom: "ACENDANT VIERGE", style: "Avant-garde Electro", scene: "Pulsar Stage", fin: "00h15" },
				]},
				{ heure: "23h30", artistes: [
				  { nom: "SHOSHANA", style: "Hard Techno/Ghetto beats/Groove", scene: "2much stage", fin: "1h00" },
				]},
				{ heure: "23h45", artistes: [
				  { nom: "VON BIKRAV", style: "Gangsta rap Gabber", scene: "Warzone Stage", fin: "00h30" },
				]},
				{ heure: "00h15", artistes: [
				  { nom: "999999999", style: "Acid Techno", scene: "Pulsar Stage", fin: "1h15" },
				]},
				{ heure: "00h30", artistes: [
				  { nom: "SUB ZERO PROJECT", style: "Hardstyle", scene: "Warzone Stage", fin: "1h30" },
				]},
				{ heure: "1h00", artistes: [
				  { nom: "SIBI", style: "Trance/Hardstyle/Hardcore oldschool", scene: "2much stage", fin: "2h15" },
				]},
				{ heure: "1h15", artistes: [
				  { nom: "OGUZ", style: "Techno", scene: "Pulsar Stage", fin: "2h15" },
				]},
				{ heure: "1h30", artistes: [
				  { nom: "ROOLER", style: "Raw Hardstyle", scene: "Warzone Stage", fin: "2h30" },
				]},
				{ heure: "2h15", artistes: [
				  { nom: "DYEN b2b STAN CHRIST", style: "Neorave / Hard Techno", scene: "Pulsar Stage", fin: "3h30" },
				  { nom: "SHANIXX", style: "Techno bitchy 2000", scene: "2much stage", fin: "3h30" },
				]},
				{ heure: "2h30", artistes: [
				  { nom: "BILLX b2b VANDAL", style: "Hardtek / Raggatek", scene: "Warzone Stage", fin: "3h30" },
				]},
				{ heure: "3h30", artistes: [
				  { nom: "REINIER ZONNEVELD b2b ANGERFIST", style: "Techno", scene: "Pulsar Stage", fin: "4h30" },
				  { nom: "SEFA", style: "Frenchcore", scene: "Warzone Stage", fin: "4h25" },
				  { nom: "DJ SCHNAKE", style: "Chipiecore/Trance/happy Hardcore/pop", scene: "2much stage", fin: "4h45" },
				]},
				{ heure: "4h25", artistes: [
				  { nom: "MISS K8 b2b ANIME", style: "Hardcore", scene: "Warzone Stage", fin: "5h20" },
				]},
				{ heure: "4h30", artistes: [
				  { nom: "VIEZE ASBAK", style: "Hard Techno", scene: "Pulsar Stage", fin: "5h15" },
				]},
				{ heure: "4h45", artistes: [
				  { nom: "AVENIR", style: "Acid rave/Hard Techno/Electro/Punk rock", scene: "2much stage", fin: "6h00" },
				]},
				{ heure: "5h15", artistes: [
				  { nom: "HADES", style: "Melodic Industrial Techno", scene: "Pulsar Stage", fin: "6h15" },
				]},
				{ heure: "5h20", artistes: [
				  { nom: "MAJOR CONSPIRACY b2b PARTYRAISER", style: "Hardcore Uptempo", scene: "Warzone Stage", fin: "6h15" },
				]},
		  ],
		};

		// "21h15" -> minutes depuis 00h00
		function toMin(str){
		  if (!str) return null;
		  const m = str.match(/^(\d{1,2})h(\d{0,2})$/i);
		  if (!m) return null;
		  const h = parseInt(m[1],10);
		  const min = m[2] ? parseInt(m[2],10) : 0;
		  return h*60 + min;
		}
		// minutes -> "21h15"
		function toHHmm(total){
		  const h = Math.floor(total/60);
		  const m = total%60;
		  return `${h}h${String(m).padStart(2,'0')}`;
		}
		// calcule [start,end] en minutes (gère la nuit : fin <= début -> +24h)
		function intervalFor(heureDebut, fin){
		  const s = toMin(heureDebut);
		  let e = fin ? toMin(fin) : (s != null ? s + 45 : null); // durée par défaut 45'
		  if (s != null && e != null && e <= s) e += 24 * 60;      // ← clé : passe-minuit
		  return [s, e];
		}
		// minutes de chevauchement (0 si aucun) — gère les slots qui passent minuit (déjà normalisés par intervalFor)
		function overlapMinutes(a, b){
		  const start = Math.max(a[0], b[0]);
		  const end   = Math.min(a[1], b[1]);
		  return Math.max(0, end - start);
		}

		function durationOf(range){ return range[1] - range[0]; }
		const WATCHABLE_MIN = 30;
		const ROLLOVER_MIN = 8 * 60;   // tout set qui commence avant 08:00 est considéré "lendemain"

		
		function overlapEdge(cur, other){
		  // chevauchement = [max(starts), min(ends)]
		  const ovStart = Math.max(cur[0], other[0]);
		  const ovEnd   = Math.min(cur[1], other[1]);
		  if (ovStart === other[0]) return 'début'; // chevauche le début de "other"
		  if (ovEnd   === other[1]) return 'fin';   // chevauche la fin de "other"
		  // sinon au milieu : on choisit le côté le plus proche pour rester lisible
		  return (ovStart - other[0]) <= (other[1] - ovEnd) ? 'début' : 'fin';
		}

		// Retourne pour un intervalle `cur` son "pire" restant vs une liste d'intervalles sélectionnés
		// => { minRemaining, dir }  dir ∈ {'avant','apres','mix','none'}
		function remainingVsSelected(cur, selectedRanges){
		  if (!selectedRanges.length) return { minRemaining: durationOf(cur), dir: 'none' };

		  let minRemaining = Infinity;
		  let dirForMin = 'mix';

		  for (const sel of selectedRanges){
			const ov = overlapMinutes(cur, sel.range);
			const remaining = durationOf(cur) - ov;

			// Détermination de la direction principale du restant vs ce `sel`
			let dir = 'mix';
			if (sel.range[1] <= cur[0]) {        // sel finit avant que cur commence
			  dir = 'avant';
			} else if (sel.range[0] >= cur[1]) { // sel commence après que cur finisse
			  dir = 'apres';
			} else {
			  // il y a recouvrement : on regarde où est la plus grosse "branche" restante
			  const avant = Math.max(0, cur[0] - sel.range[0]);
			  const apres = Math.max(0, sel.range[1] - cur[1]);
			  if (avant > apres) dir = 'avant';
			  else if (apres > avant) dir = 'apres';
			  else dir = 'mix';
			}

			if (remaining < minRemaining){
			  minRemaining = remaining;
			  dirForMin = dir;
			}
		  }
		  return { minRemaining: Math.max(0, minRemaining), dir: dirForMin };
		}


		// chevauchement strict (si b commence avant que a finisse ET b finit après que a commence)
		function overlap(a,b){ return a[0] < b[1] && b[0] < a[1]; }
		
		// Recalcule les conflits pour un jour donné (sans désactiver le clic)
		function updateConflictsForDay(jour){
		  // 1) Récupère tous les créneaux déjà sélectionnés (avec heures)
		  const selectedIntervals = [];
		  (donneesFestival[jour] || []).forEach(slot=>{
			const checked = document.querySelector(`input[name="${jour}_${slot.heure}"]:checked`);
			if (!checked || checked.value === "Aucun") return;
			const lab = checked.closest('.option');
			const s = parseInt(lab?.dataset.start ?? '', 10);
			const e = parseInt(lab?.dataset.end   ?? '', 10);
			if (!isNaN(s) && !isNaN(e)) selectedIntervals.push({range:[s,e], el:lab});
		  });

		  // 2) Réinitialise l'état visuel
		  document.querySelectorAll(`.option[data-jour="${jour}"]`).forEach(l=>{
			l.classList.remove('conflict');
		  });

			// 3) Marque en conflit/partiel ET écrit une note "Chevauche XX min début/fin de NOM"
			document.querySelectorAll(`.option[data-jour="${jour}"]`).forEach(l=>{
			  const inp = l.querySelector('input[type="radio"]');
			  const noteEl = l.querySelector('.ov-note');
			  if (noteEl) noteEl.textContent = ''; // reset note

			  if (!inp || inp.value === 'Aucun') return;

			  const s = parseInt(l.dataset.start ?? '', 10);
			  const e = parseInt(l.dataset.end   ?? '', 10);
			  if (isNaN(s) || isNaN(e)) return;

			  const cur = [s,e];
			  let maxOv = 0;
			  let worstRemaining = Infinity;
			  let worstDir = 'mix';
			  let bestOther = null; // label de l'autre show le plus "impactant"

			  for (const sel of selectedIntervals){
				if (sel.el === l) continue;
				const ov = overlapMinutes(cur, sel.range);
				if (ov > 0){
				  // suivi pour la note : garder celui avec le plus gros chevauchement
				  if (ov > maxOv){
					maxOv = ov;
					bestOther = sel.el; // label DOM de l’autre sélectionné
				  }
				  const rem = durationOf(cur) - ov;
				  if (rem < worstRemaining){
					worstRemaining = rem;
					// direction globale (avant/après/mix) – on la réutilise moins maintenant
					worstDir = remainingVsSelected(cur, [sel]).dir;
				  }
				}
			  }

			  l.classList.remove('conflict','partial');
			  delete l.dataset.remmin;
			  delete l.dataset.dir;

			  if (!selectedIntervals.length || maxOv === 0){
				return; // rien de choisi ou pas de recouvrement -> pas de badge/note
			  }

			  // Remplir la note lisible si on a un "other"
			  if (bestOther){
				const otherName = bestOther.querySelector('strong')?.textContent || 'autre show';
				const edge = overlapEdge(cur, [
				  parseInt(bestOther.dataset.start,10),
				  parseInt(bestOther.dataset.end,10)
				]);
				if (noteEl) noteEl.textContent = `Chevauche ${maxOv} min ${edge} de ${otherName}`;
			  }

			  // Décision visuelle: conflit si le "pire restant" < seuil, sinon partiel
			  if (worstRemaining < WATCHABLE_MIN){
				l.classList.add('conflict');
				l.dataset.remmin = String(Math.max(0, worstRemaining));
			  } else {
				l.classList.add('partial');
				l.dataset.remmin = String(Math.max(0, worstRemaining));
			  }
			});
		}

	  function demarrerChoix() {
		joursChoisis = Array.from(document.querySelectorAll('#selection-jours input[type=checkbox]:checked')).map(cb => cb.value);
		document.getElementById('selection-jours').classList.add('hidden');
		genererChoix();
	  }

	  function genererChoix() {
		  const choixDiv = document.getElementById('choix');
		  choixDiv.innerHTML = '';

		  joursChoisis.forEach(jour => {
			const jourDiv = document.createElement('div');
			jourDiv.classList.add('day-group');
			jourDiv.innerHTML = `<h3>${jour}</h3>`;
			if (!donneesFestival[jour]) return;

			donneesFestival[jour].forEach(slot => {
			  const slotDiv = document.createElement('div');
			  slotDiv.className = 'slot';

			  const hEl = document.createElement('div');
			  hEl.className = 'heure';
			  hEl.textContent = slot.heure || '';
			  slotDiv.appendChild(hEl);

			  const options = document.createElement('div');
			  options.className = 'options';
			  const groupName = `${jour}_${slot.heure}`;

			  // "Aucun"
			  const optNone = document.createElement('label');
			  optNone.className = 'option option-none selected';
			  optNone.innerHTML = `
				<input type="radio" name="${groupName}" value="Aucun" checked>
				<strong>Aucun</strong>
				<small>—</small>
			  `;
			  options.appendChild(optNone);

			// Artistes
			(slot.artistes || []).forEach((a, idx) => {
			const [sMin, eMin] = intervalFor(slot.heure, a.fin);
			const endStr = (eMin != null)
			  ? toHHmm(eMin % (24*60))
			  : (toMin(slot.heure) != null ? toHHmm((toMin(slot.heure) + 45) % (24*60)) : "");

			  const id = `${groupName}_art${idx}`;
			  const opt = document.createElement('label');
			  opt.className = 'option';
			// normalisation "lendemain" pour les sets après minuit (ex: 00h30–01h30)
			let sNorm = sMin, eNorm = eMin;
			if (sNorm != null && sNorm < ROLLOVER_MIN) { sNorm += 24*60; eNorm += 24*60; }

			opt.dataset.jour  = jour;
			opt.dataset.start = sNorm ?? '';
			opt.dataset.end   = eNorm ?? '';


			  opt.innerHTML = `
				<input type="radio" id="${id}" name="${groupName}" value="${a.nom}">
				<strong>${a.nom}</strong>
				<small>${a.style} <span style="opacity:.6">•</span> ${a.scene}<br>
				<span class="time">${slot.heure}${endStr ? '–'+endStr : ''}</span></small>
			  `;
				const note = document.createElement('div');
				note.className = 'ov-note';
				opt.appendChild(note);
			  options.appendChild(opt);
			});


			  slotDiv.appendChild(options);
			  jourDiv.appendChild(slotDiv);
			});

			choixDiv.appendChild(jourDiv);
		  });

		  // ← Un SEUL bouton, ajouté proprement en JS
		  const validateBtn = document.createElement('button');
		  validateBtn.type = 'button';
		  validateBtn.textContent = 'Valider mes choix';
		  validateBtn.addEventListener('click', afficherResultats);
		  choixDiv.appendChild(validateBtn);
		  recomputeAllConflicts();  // première passe une fois l'UI construite
		  choixDiv.classList.remove('hidden');
		}


	  function afficherResultats() {
		const resultatsDiv = document.getElementById('resultats');
		const listeResultats = document.getElementById('liste-resultats');

		// Nettoyage
		listeResultats.innerHTML = '';
		resultatsDiv.querySelectorAll('.back-btn').forEach(btn => btn.remove());

		// Styles du tableau (fond blanc + lignes violettes)
		const cellStyle   = 'border: 1px solid #8000ff; padding: 8px; font-size: 1em; color: #111; background-color: #ffffff;';
		const headerStyle = 'border: 1px solid #8000ff; padding: 8px; font-size: 1em; font-weight: bold; background-color: #8000ff; color: #ffffff;';

		joursChoisis.forEach(jour => {
		  if (!donneesFestival[jour]) return;

			// ---- Titre de jour
			const titre = document.createElement('h2');
			titre.className = 'jour-titre';
			titre.textContent = jour;
			listeResultats.appendChild(titre);

			// ---- Récupère les choix sélectionnés (avec heures)
			const selected = [];
			(donneesFestival[jour] || []).forEach(slot => {
			  const checked = document.querySelector(`input[name="${jour}_${slot.heure}"]:checked`);
			  if (!checked || checked.value === "Aucun") return;
			  const artiste = slot.artistes.find(a => a.nom === checked.value);
			  if (!artiste) return;
				const [sMin, eMin] = intervalFor(slot.heure, artiste.fin);

				// normalisation "lendemain" pour l’ordre et la timeline
				let sNorm = sMin, eNorm = eMin;
				if (sNorm != null && sNorm < ROLLOVER_MIN) { sNorm += 24*60; eNorm += 24*60; }

				selected.push({
				  start: sNorm, end: eNorm,                      // ← valeurs normalisées pour TRI & TIMELINE
				  debutStr: slot.heure,
				  finStr: toHHmm(eMin % (24*60)),                // ← affichage "humain" (00h15, 01h00…)
				  nom: artiste.nom, scene: artiste.scene, style: artiste.style
				});
			});

			// Rien de sélectionné pour ce jour
			if (!selected.length){
			  const p = document.createElement('p');
			  p.textContent = "Aucun choix validé pour ce jour.";
			  listeResultats.appendChild(p);
			  return;
			}

			// ---- Tri par début
			selected.sort((a,b)=>a.start-b.start);

			// ---- Calcul des notes et du statut (partial / conflict)
			const WATCHABLE_MIN = 30;
			function overlapMinutes(a,b){
			  const st = Math.max(a.start, b.start);
			  const en = Math.min(a.end,   b.end);
			  return Math.max(0, en - st);
			}
			function durationOf(x){ return x.end - x.start; }
			function overlapEdge(cur, other){
			  const ovStart = Math.max(cur.start, other.start);
			  const ovEnd   = Math.min(cur.end,   other.end);
			  if (ovStart === other.start) return 'début';
			  if (ovEnd   === other.end)   return 'fin';
			  return (ovStart - other.start) <= (other.end - ovEnd) ? 'début' : 'fin';
			}

			const enriched = selected.map((cur, idx)=>{
			  // on cherche le chevauchement le plus “impactant”
			  let maxOv = 0, bestOtherIndex = -1, worstRemaining = durationOf(cur);
			  for (let j=0;j<selected.length;j++){
				if (j===idx) continue;
				const other = selected[j];
				const ov = overlapMinutes(cur, other);
				if (ov>0){
				  if (ov>maxOv){ maxOv = ov; bestOtherIndex = j; }
				  const remaining = durationOf(cur) - ov;
				  if (remaining < worstRemaining) worstRemaining = remaining;
				}
			  }
			  let status = null, note = "";
			  if (maxOv>0 && bestOtherIndex>=0){
				const other = selected[bestOtherIndex];
				const edge = overlapEdge(cur, other); // "début" ou "fin" de l'autre
				if (worstRemaining < WATCHABLE_MIN){
				  status = 'conflict';
				  note = `Chevauche ${maxOv} min ${edge} de ${other.nom}`;
				} else {
				  status = 'partial';
				  note = `Chevauche ${maxOv} min ${edge} de ${other.nom}`;
				}
			  }
			  return {...cur, status, note};
			});

			// ---- Mini-timeline: échelle commune
			const minStart = Math.min(...enriched.map(x=>x.start));
			const maxEnd   = Math.max(...enriched.map(x=>x.end));
			const span     = Math.max(1, maxEnd - minStart); // sûreté

			// ---- Création du tableau
			const table = document.createElement('table');

			// En-têtes (Début / Fin / Artiste / Scène / Style / Note / Timeline)
			const headerRow = document.createElement('tr');
			['Début','Fin','Artiste','Scène','Style','Note','Timeline'].forEach(text => {
			  const th = document.createElement('th');
			  th.style.cssText = headerStyle;
			  th.textContent = text;
			  headerRow.appendChild(th);
			});
			table.appendChild(headerRow);

			// Lignes
			enriched.forEach(item=>{
			  const tr = document.createElement('tr');

			  // Début
			  let td = document.createElement('td'); td.style.cssText = cellStyle; td.textContent = item.debutStr; tr.appendChild(td);
			  // Fin
			  td = document.createElement('td'); td.style.cssText = cellStyle; td.textContent = item.finStr; tr.appendChild(td);
			  // Artiste
			  td = document.createElement('td'); td.style.cssText = cellStyle; td.textContent = item.nom; tr.appendChild(td);
			  // Scène
			  td = document.createElement('td'); td.style.cssText = cellStyle; td.textContent = item.scene; tr.appendChild(td);
			  // Style
			  td = document.createElement('td'); td.style.cssText = cellStyle; td.textContent = item.style; tr.appendChild(td);
			  // Note (badge)
			  td = document.createElement('td'); td.style.cssText = cellStyle;
			  if (item.note){
				const b = document.createElement('span');
				b.className = 'note-badge ' + (item.status || 'partial');
				b.textContent = item.note;
				td.appendChild(b);
			  } else {
				td.textContent = '';
			  }
			  tr.appendChild(td);

			  // Timeline
			  td = document.createElement('td'); td.style.cssText = cellStyle;
			  const tl = document.createElement('div'); tl.className='tl-cell';
			  const bar = document.createElement('div'); bar.className='tl-range';
			  const leftPct  = ((item.start - minStart) / span) * 100;
			  const widthPct = ((item.end   - item.start) / span) * 100;
			  bar.style.left  = leftPct.toFixed(2) + '%';
			  bar.style.width = widthPct.toFixed(2) + '%';
			  const label = document.createElement('div'); label.className='tl-label';
			  label.textContent = `${item.debutStr}–${item.finStr}`;
			  tl.appendChild(bar); tl.appendChild(label);
			  td.appendChild(tl);
			  tr.appendChild(td);

			  table.appendChild(tr);
			});

			listeResultats.appendChild(table);

		});

		// Bouton retour (unique)
		const backBtn = document.createElement('button');
		backBtn.type = 'button';
		backBtn.className = 'back-btn';
		backBtn.textContent = '⬅️ Revenir aux choix';
		backBtn.addEventListener('click', revenirAuxChoix);
		resultatsDiv.appendChild(backBtn); // <-- manquait

		document.getElementById('choix').classList.add('hidden');
		resultatsDiv.classList.remove('hidden');
	  }

	  function revenirAuxChoix() {
		const res = document.getElementById('resultats');
		res.querySelectorAll('.back-btn').forEach(btn => btn.remove());
		res.classList.add('hidden');
		document.getElementById('choix').classList.remove('hidden');
	  }

	  function genererPDF() {
		const { jsPDF } = window.jspdf;
		const doc = new jsPDF('l', 'pt', 'a4');
		doc.html(document.getElementById('liste-resultats'), {
		  callback: function (doc) { doc.save('RunningOrder.pdf'); },
		  margin: [40, 20, 40, 20],
		  autoPaging: 'text',
		  html2canvas: { scale: 0.8 }
		});
	  }

		document.addEventListener('change', (e) => {
		  if (!e.target.matches('.option input[type="radio"]')) return;

		  const input = e.target;
		  const group = input.name;                 // ex: "Vendredi_23h15"
		  const jour  = group.split('_')[0];        // "Vendredi"

		  // 1) Visuel "selected" dans le groupe courant
		  document.querySelectorAll(`input[name="${group}"]`).forEach(inp => {
			const card = inp.closest('.option');
			if (card) card.classList.toggle('selected', inp.checked && inp === input);
		  });

		  // 2) Si on a choisi un ARTISTE (pas "Aucun"), on ne désélectionne les autres
		  //    que si EUX n'ont plus assez de "restant" (< WATCHABLE_MIN)
		  const curLabel = input.closest('.option');
		  const s = parseInt(curLabel?.dataset.start || '', 10);
		  const eEnd = parseInt(curLabel?.dataset.end   || '', 10);

		  if (input.value !== 'Aucun' && !isNaN(s) && !isNaN(eEnd)) {
			const curRange = [s, eEnd];

			// Parcourt tous les autres créneaux choisis de ce jour
			(donneesFestival[jour] || []).forEach(slot => {
			  const gname = `${jour}_${slot.heure}`;
			  if (gname === group) return; // pas le créneau courant

			  const checked = document.querySelector(`input[name="${gname}"]:checked`);
			  if (!checked || checked.value === 'Aucun') return;

			  const lab = checked.closest('.option');
			  const s2 = parseInt(lab?.dataset.start || '', 10);
			  const e2 = parseInt(lab?.dataset.end   || '', 10);
			  if (isNaN(s2) || isNaN(e2)) return;

			  const otherRange = [s2, e2];
			  const ov = overlapMinutes(curRange, otherRange);

				if (ov > 0){
				  const remainingOther = durationOf(otherRange) - ov;
				  const remainingNew   = durationOf(curRange)  - ov;

				  // Nouvelle règle :
				  // - si le NOUVEAU garde >= seuil (ex. 30'), on autorise la cohabitation (on ne touche pas à l'autre)
				  // - si chacun garde >= seuil -> cohabitation aussi
				  // - on ne dé-sélectionne l'autre QUE si LES DEUX < seuil → on garde le nouveau, on met l'autre à "Aucun"
				  if (remainingNew < WATCHABLE_MIN && remainingOther < WATCHABLE_MIN){
					const none = document.querySelector(`input[name="${gname}"][value="Aucun"]`);
					if (none) {
					  none.checked = true;
					  document.querySelectorAll(`input[name="${gname}"]`).forEach(inp => {
						const c = inp.closest('.option');
						if (c) c.classList.toggle('selected', inp.checked);
					  });
					}
				  }
				}
			});
		  }

		  // 3) Recalcule l’habillage de conflit/partiel pour le jour
		  updateConflictsForDay(jour);
		});


		// Recalcule tous les jours sélectionnés
		function recomputeAllConflicts(){
		  (joursChoisis || []).forEach(updateConflictsForDay);
		}
		
	window.addEventListener('DOMContentLoaded', () => {
	  const start = document.getElementById('btnStart');
	  if (start) start.addEventListener('click', demarrerChoix);
	  
});


  </script>

</body>
</html>
